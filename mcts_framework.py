# -*- coding: utf-8 -*-
"""MCTS_framework

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PnszDu1ydKmpr7Rjl1vAdu6UzkCiaP7v
"""

import random
import math
from collections import defaultdict
from math import sqrt , log
from sympy import symbols , solve

class TransformerPlanner:
  def __init__(self):
    self.strategies = [
        "Apply the Angle Bisector Theorem.",
            "Use Power of a Point.",
            "Consider circles centered at C.",
            "Apply the Pigeonhole Principle.",
            "Use modular arithmetic."
    ]
  def generate_strategies(self,problem):
    k = min(2,len(self.strategies))
    return random.sample(self.strategies, k=k)

class MCTSNode:
  def __init__(self,state,parent = None):
    self.state = state
    self.parent = parent
    self.children = []
    self.visits = 0
    self.value = 0
  def expand(self):
    strategies = TransformerPlanner().generate_strategies(self.state)
    for strategy in strategies:
      child_state = self.state + f"\nApplied: {strategy}"
      self.children.append(MCTSNode(child_state, self))
  def select(self):
    if not self.children:
      return self
      return max(self.children, key=lambda child:
                 (child.value/(child.visits + 1e-6))+(sqrt(2)*sqrt(log(self.visits + 1) / (child.visits + 1e-6))))
  def simulate(self):
    return random.random()

  def backpropagate(self,reward):
    self.visits +=1
    self.value += reward
    if self.parent:
      self.parent.backpropagate(reward)

class MCTS:
  def __init__(self, initial_state):
    self.root = MCTSNode(initial_state)
  def search(self, iterations=100):
    for _ in range(iterations):
      node = self.root
      while node.children and all(child.visits > 0 for child in node.children):
        node = node.select()
      if node.visits > 0 and not node.children:
          node.expand()
          if node.children:
            node = random.choice(node.children)
      reward = node.simulate()
      node.backpropagate(reward)

      if not self.root.children:
        return self.root

      return max(self.root.children, key = lambda child: child.visits)

class RuleBasedDeduction:
  def __init__(self):
    self.rules = {
        "CX = CY": "Consider circles centered at C.",
        "BX bisects ∠CBA": "Apply the Angle Bisector Theorem.",
        "AB = BC": "Use the Power of a Point."
    }

  def apply_rules(self,problem):
    applied_rules = []
    for condition , rule in self.rules.items():
      if condition in problem:
        applied_rules.append(rule)
    return applied_rules

class BruteForceSearch:
  def __init__(self):
        pass

  def search(self, problem):
      # Mock implementation for small problem spaces
      return "Brute-force solution found."

class BackwardChaining:
    def __init__(self):
        pass

    def solve(self, goal, problem):
        steps = []
        if "Find m + n" in goal:
            steps.append("Derive BE = m/n.")
            steps.append("Apply the Angle Bisector Theorem.")
        return steps

if __name__ == "__main__":
  problem = "Let ABC be a triangle with BC = 108, CA = 126, and AB = 39. Point X lies on segment AC such that BX bisects ∠CBA. Let ω be the circumcircle of triangle ABX. Let Y be a point on ω different from X such that CX = CY. Line XY meets BC at E. The length of the segment BE can be written as m/n, where m and n are coprime positive integers. Find m + n."

  planner  = TransformerPlanner()
  strategies = planner.generate_strategies(problem)
  print("Generated Strategies:", strategies)

  mcts = MCTS(problem)
  best_node = mcts.search(iterations = 50)
  print("Best Proof Path: " , best_node.state)

  rule_solver = RuleBasedDeduction()
  applied_rules = rule_solver.apply_rules(problem)
  print("Applied Rules:", applied_rules)

  brute_force_solver = BruteForceSearch()
  solution_steps = brute_force_solver.search(problem)
  print("Brute force solution:", solution_steps)

  backward_chaining_solver = BackwardChaining()
  solver_steps = backward_chaining_solver.solve("Find m + n", problem)
  print("Backward chaining steps:", solver_steps)