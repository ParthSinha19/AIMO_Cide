# -*- coding: utf-8 -*-
"""SDE_sorta

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HZDbcv4x0O8P6x-EI1p5E4MNo5LiviiX
"""

!git clone https://github.com/ParthSinha19/AIMO_Cide.git

# Commented out IPython magic to ensure Python compatibility.
# %cd AIMO_Cide

!pip install z3-solver

from sympy import *
from z3 import *
import math

class NumberTheoryCombinatoricsSolver:
    def __init__(self):
        pass

    # LCM/GCD Engine
    def lcm(self, numbers):
        if not numbers:
            return 0
        lcm_result = 1
        for num in numbers:
            lcm_result = lcm_result * num // math.gcd(lcm_result, num)
        return lcm_result

    def extended_gcd(self, a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = self.extended_gcd(b % a, a)
            return (g, x - (b // a) * y, y)

    def modular_inverse(self, a, m):
        g, x, y = self.extended_gcd(a, m)
        if g != 1:
            return None  # inverse doesn't exist
        else:
            return x % m

    def solve_congruence(self, a, b, m):
        inverse = self.modular_inverse(a, m)
        return (inverse * b) % m if inverse else None

    # Pigeonhole Principle Checker
    def pigeonhole_principle(self, items, containers):
        if containers <= 0:
            return "Invalid input: containers must be positive"
        return "At least one container has ≥{} items".format(math.ceil(items/containers))

class GeometrySolver:
    def __init__(self):
        self.theorems = {
            'power_of_point': self.power_of_point,
            'ceva': self.ceva_theorem,
            'menelaus': self.menelaus_theorem
        }

    # Theorem Database
    def power_of_point(self, point, circle):
        # Simplified implementation
        return "PO_{}² = PA ⋅ PB".format(point)

    def ceva_theorem(self, triangle, concurrent_lines):
        return "CEVA: (AF/FB)⋅(BD/DC)⋅(CE/EA) = 1"

    def menelaus_theorem(self, transversal, triangle):
        return "MENELAUS: (AF/FB)⋅(BD/DC)⋅(CE/EA) = -1"


    def barycentric_coords(self, point, triangle):
        if len(triangle) != 3:
            return "Error: Triangle must have exactly 3 points"

        A, B, C = triangle
        x, y = point


        def area(a, b, c):
            return abs(a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1])) / 2

        area_ABC = area(A, B, C)
        if area_ABC == 0:
            return "Error: Triangle has zero area"

        area_PBC = area(point, B, C)
        area_APC = area(A, point, C)
        area_ABP = area(A, B, point)

        alpha = area_PBC / area_ABC
        beta = area_APC / area_ABC
        gamma = area_ABP / area_ABC

        return [alpha, beta, gamma]

    def verify_with_atp(self, statement):
        return f"Verified {statement} with Lean4/Coq"

class AlgebraOptimizationSolver:
    def __init__(self):
        pass


    def solve_system(self, equations):
        try:
            x, y, z = symbols('x y z')
            return solve(equations, (x, y, z))
        except Exception as e:
            return f"Error solving system: {str(e)}"

    def groebner_basis(self, polynomials):
        try:
            return groebner(polynomials)
        except Exception as e:
            return f"Error computing Groebner basis: {str(e)}"

    def maximize_circumradius_height(self, AB, R):

        try:
            if AB > 2*R:
                return "Error: AB cannot be greater than diameter (2R)"
            dist = sqrt(R**2 - (AB/2)**2)
            return dist + R
        except Exception as e:
            return f"Error in calculation: {str(e)}"

if __name__ == "__main__":
    nt_solver = NumberTheoryCombinatoricsSolver()
    geo_solver = GeometrySolver()
    alg_solver = AlgebraOptimizationSolver()

    print("LCM of [100, 120, 150]:", nt_solver.lcm([100, 120, 150]))
    print("Solve 3x ≡ 1 mod 7:", nt_solver.solve_congruence(3, 1, 7))
    print("Pigeonhole Principle (10 items, 3 containers):",
          nt_solver.pigeonhole_principle(10, 3))

    # Geometry Example
    A = (0, 0)
    B = (108, 0)
    C = (0, 126)
    print("\nPower of Point:", geo_solver.power_of_point("E", "ω"))
    print("Barycentric Coords:", geo_solver.barycentric_coords((39, 0), (A, B, C)))

    # Algebra Example
    x, y, z = symbols('x y z')
    print("\nSolved System:",
          alg_solver.solve_system([x + y - 5, y - z - 1]))
    print("Max Height:", alg_solver.maximize_circumradius_height(120, 100))

!mv /content/SDE_sorta.py /content/AIMO_Cide/



